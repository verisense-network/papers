\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{authblk}

\usepackage{draftwatermark}
\SetWatermarkText{\shortstack
  {Monadring: A lightweight consensus protocol for organizing subnets upon a blockchain system
}}
\SetWatermarkLightness{0.05}
\SetWatermarkScale{0.5}


\bibliographystyle{plain}

\begin{document}

\title{Monadring: A lightweight consensus protocol for organizing subnets upon a blockchain system}
\author[*]{Zhang Yu}
\author[*]{Yan Xiao}
\author[*]{Gang Tang}
\author[*]{Helena Wang}
\affil[*]{Verisense}
\date{June 15, 2024}
\maketitle

\begin{abstract}
Existing blockchain networks are often large-scale, requiring transactions to be synchronized across the entire network to reach consensus, and on-chain computations can be prohibitively expensive, making many CPU-sensitive computations infeasible.

Inspired by the structure of IBM's token ring networks, we propose a lightweight consensus protocol called Monadring to address these issues. Monadring allows nodes that are already part of a large blockchain network to form a smaller subnetwork to perform computations more quickly and cheaply, while still maintaining the same security guarantees as the main blockchain network.

To further enhance the security of Monadring, we introduce a node rotation mechanism based on Fully Homomorphic Encryption (FHE) within the smaller subnetwork. Unlike the common voting-based election of validator nodes, the election in Monadring leverages FHE to hide the voting information, eliminating the advantage of the last mover in the voting game.

The paper details the design and implementation of the Monadring protocol, and evaluates its performance and feasibility through simulation experiments. This research contributes to enhancing the practical utility of blockchain technology in large-scale application scenarios.
\end{abstract}

\section{Introduction}
Recent blockchain systems have often adopted faster and more energy-efficient consensus protocols like Ouroboros, BABE, and Tendermint.
Blockchain networks are typically open and permissionless, and we can define the degree of decentralization of such networks by the number of participating nodes.
Leveraging the consensus protocols mentioned earlier, it is possible to rapidly construct new blockchain networks.
However, decentralized applications often cannot flexibly customize their degree of decentralization based on the importance of their underlying data.

For example, decentralized social media applications may require faster response times and lower storage costs compared to decentralized finance applications, and hence may need a lower degree of decentralization.
This flexibility to adjust the level of decentralization based on the needs of the application is an important consideration that has not been fully addressed in existing blockchain architectures.

Building a subnetwork over an existing blockchain system is a possible way to address this issue.
By drawing inspiration from the token ring architecture, we propose a novel consensus protocol called Monadring that aims to enable nodes within an existing blockchain network to form smaller, lightweight subnetworks capable of performing computations more efficiently and cost-effectively, while still maintaining the same security guarantees as the main blockchain.

Token ring network operates at the data link layer of the OSI/RM model.
It was designed to solve the problem of physical link contention just like Ethernet.
In a token ring network, a token is passed sequentially from one node to the next, granting the holder the right to transmit data.
This token-based system for managing access to the shared medium bears some similarity to the consensus mechanisms used in blockchain networks for selecting block producer.

Despite the fact that token ring networks have largely fallen out of favor in modern networking due to their limited scalability and other drawbacks, the underlying principles of their decentralized, token-based structure could provide valuable insights for designing a lightweight consensus algorithm for small blockchain systems.

Monadring also involves FHE-based member rotation mechanism to enhance the security.
Homomorphic encryption (HE) is a method of encryption that allows computations to be carried out on encrypted data, generating an encrypted result which, when decrypted, matches the outcome of computations performed on the plaintext.
This property enables sophisticated computations on encrypted data while maintaining data security.
HE schemes are a type of encryption method that can protect data privacy because they allow computations to be performed directly on the encrypted data.
For example, an HE scheme might allow a user to perform operations like addition and multiplication on encrypted numbers, and these operations would have the same result as if they were performed on the original, unencrypted numbers.
This technology is seen as a key component for secure cloud computing since it allows complex data manipulations to be carried out on completely secure encrypted data.

Fully Homomorphic Encryption (FHE) is a more advanced form of Homomorphic Encryption.
FHE allows arbitrary computations to be carried out on encrypted data, which is not the case with normal HE which might be limited in the types of computation it supports.
FHE computations generate a result that, when decrypted, corresponds to the result of the same computations performed on the plaintext.
This makes FHE extremely useful for cases where sensitive data must be processed or analyzed, but security and privacy considerations prevent the data from being decrypted.
With FHE, you can perform unlimited calculations on this encrypted data just like you would on unencrypted data. For instance, in the field of cloud computing, FHE allows users to operate computations on encrypted data stored in the cloud, preserving data confidentiality and privacy.

\section{Definitions and Model}
\subsection{FHE}
Some of the more popular FHE frameworks include BFV, BGV and CKKS.
\begin{itemize}
\item \textbf{BGV (Brakerski-Gentry-Vaikuntanathan)}: The BGV scheme is a Fully Homomorphic Encryption (FHE) method, proposed by Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan.
It offers a choice of FHE schemes based on the learning with error (LWE) or ring-LWE problems that have substantial security against known attacks.
BGV allows the encryption of a single bit at a time and the efficiency of the encryption is largely considered in cloud storage models.
\item \textbf{BFV (Brakerski/Fan-Vercauteren)}: BFV is another homomorphic encryption scheme that is often considered for its practical performance alongside the BGV scheme.
BFV supports a set of mathematical operations such as addition and multiplication to be performed directly on the encrypted data.
It has been implemented efficiently and there have also been several optimizations proposed to enhance its performance in different applications.
\item \textbf{CKKS (Cheon-Kim-Kim-Song)}: The CKKS scheme is known for being a Leveled Homomorphic Encryption method that supports approximate arithmetic operations over encrypted data.
The CKKS scheme is especially suitable for computations involving real or complex numbers.
Its ability to perform operations on encrypted data without the necessity for decryption makes it highly useful for maintaining data security during computations.
\end{itemize}
The Brakerski-Gentry-Vaikuntanathan (BGV) and Brakerski/Fan-Vercauteren (BFV) schemes differ mainly in how they encode information.
BGV encodes messages in the least significant digit (LSD) of the integer, while BFV encodes messages in the most significant digit (MSD) of the integer.
This difference can affect how the encrypted data is handled and manipulated during computations.

\paragraph{Mathematic notations of FHE.}
We define the symbol $\mathbb{Z}$ as the set of integers, $\mathbb{Q}$ as the field of rational numbers, $\mathbb{R}$ as the field of real numbers, and $\mathbb{C}$ as the field of complex numbers.

Further, we define the polynomial cyclotomic ring $\mathcal{R}$ as follows: $$\mathcal{R}:=\mathbb{Z}[X]/(X^N+1)$$ Correspondingly, $\mathcal{R}_q$ is defined as $(\mathbb{Z}/q\mathbb{Z})[X]/(X^N+1)$, where typically $N=2^n$, that is, $N$ is an integer power of 2.

We define a distribution as $\chi_{\sigma^2,\mu}$, where $\sigma^2$ denotes the variance and $\mu$ signifies the mean. The uniform ternary distribution and discrete Gaussian distribution are represented by $\chi_\mathcal{T}$ and $\chi_\mathcal{N}$ respectively. Considering the standard BFV encryption formula: $$\mathbf{a}\cdot \mathbf{s} +\Delta m +\mathbf{e}$$
It's established that $\mathbf{a}\sim\chi_\mathcal{T}$ and $\mathbf{e}\sim\chi_{\mathcal{N}}$.
Wherein, the probability density function of the discrete Gaussian distribution is represented as $\rho_{\mu,\sigma^2}=e^{-\lVert\mathbf{x}-\mathbf{\mu}\rVert^2/2\sigma^2}$.

The expansion factor $\delta_\mathcal{R}$ is defined as $\lVert \mathbf{a}\cdot\mathbf{b}\rVert_\infty/(\lVert\mathbf{a}\rVert_\infty\cdot\lVert\mathbf{b}\rVert_\infty)$ where $\mathbf{a},\mathbf{b}\in \mathcal{R}$

\paragraph{Shamir Secret Sharing Scheme.}
Shamir's Secret Sharing is an algorithm in cryptography devised by Adi Shamir. It's a form of secret sharing, where a secret is divided into parts, giving each participant its own unique part. The unique feature of the algorithm is the minimal amount of parts, or shares, needed to reconstruct the secret.
Here's a simple walkthrough of how Shamir's Secret Sharing can be used for threshold private key sharing:
\begin{enumerate}
\item Choose the Threshold: Define the threshold number $t$ below which knowing $t$ points gives no information about the secret, but $t$ points yields the secret.
\item Generate a Polynomial: Generate a random polynomial of degree $t-1$ with the constant term being the secret (private key) to be shared. i.e. \begin{equation}\mathcal{P}(\mathbf{x})=a_0+a_1\mathbf{x}+a_2\mathbf{x}^2+\ldots+a_{t-1}\mathbf{x}^{t-1}
\end{equation}
\item Create Shares: Evaluate the polynomial at different points to get $n$ shares, where $n$ is the total number of participants. Each participant is given one share, which is a point on the polynomial. i.e. \begin{equation}s_i=\mathcal{P}(\mathbf{x}_i)\end{equation}
\item Distribute the Shares: The shares of the private key are then distributed among the participants.
The key property here is that any $t$ shares (points) are enough to reconstruct the polynomial (and hence discover the secret), whereas $t-1$ or fewer shares reveal no information about the secret.
\item Reconstruct the Secret: When the need arises to use the private key (secret), any $t$ participants come together and combine their shares using polynomial interpolation (for example, via Lagrange interpolation) to reconstruct the polynomial and discover the constant term, which is the secret.
\begin{equation}
\mathcal{P}(x)=\sum^{t-1}_{i=0}s_i\prod_{j\neq i}\frac{x-s_j}{s_i-s_j}
\end{equation}

\end{enumerate}
It is worth noting that all polynomials are defined over the ring of polynomials in $(\mathbb{Z}/p\mathbb{Z})[X]/X^{t}$ and the Lagrange interpolation still holds.

This way, the private key (secret) is never explicitly revealed to any single party and no single party can access the secret alone.
This is particularly useful in managing the risks associated with key management in cryptographic systems.
It provides a balance between accessibility (through the threshold number of participants) and security (no single point of failure).

\paragraph{BFV Scheme.}
As described in the citation \cite{10.1007/978-3-642-32009-5_50, cryptoeprint:2012/144}, the BFV scheme proposes the method of placing the ciphertext in the Most Significant Digit (MSD) position, which makes the trend of noise growth change from quadratic to linear. This not only greatly reduces the influence of noise in the computation process, but also eliminates the need for modulus switching, thus effectively enhancing the computational efficiency.

\begin{itemize}
\item \texttt{BFV.SecretKeyGen($1^\lambda$)}: Generate a secret key $\texttt{sk}\leftarrow \chi_\mathcal{T}$.
\item \texttt{BFV.PublicKeyGen(\texttt{sk})}: Generate a public key $\texttt{pk} =(\texttt{pk}_0,\texttt{pk}_1)= \left([-\mathbf{a}\cdot\mathbf{s}+\mathbf{e}]_{q}, \mathbf{a}\right)$ where $\mathbf{e}\leftarrow \chi_\mathcal{N}$ and $\mathbf{a}\leftarrow \chi_\mathcal{T}$.
\item \texttt{BFV.Enc($\texttt{pk},\textbf{m}$)}: Message $\mathbf{m}\in \mathcal{R}_p$, where $p<q$. $\mathbf{u}\leftarrow \chi_\mathcal{T}$ and $\mathbf{e}_0, \mathbf{e}_1\leftarrow \chi_\mathcal{N}$. The ciphertext is $$\texttt{ct} = (\texttt{ct}_0,\texttt{ct}_1)=\left([\texttt{pk}_0\cdot\mathbf{u}+\Delta\cdot\mathbf{m}+\mathbf{e}_0]_{q},[\texttt{pk}_1\cdot\mathbf{u}+\mathbf{e}_1]_{q}\right)$$
\item \texttt{BFV.Dec($\texttt{sk},\texttt{ct}$)}: $$\mathbf{m}=\left[\left\lfloor p\cdot[\texttt{ct}_0+\texttt{ct}_1\cdot\mathbf{s}]_q/q\right\rceil\right]_t$$
\end{itemize}
It is worth noting that the BFV scheme differs from the BGV scheme in that the BGV ciphertext is placed in LSD, i.e.
\begin{itemize}
\item \texttt{BGV.PublicKeyGen(\texttt{sk})}: $$\texttt{pk}=([-\mathbf{a}\cdot{s}+p\mathbf{e}]_q, \mathbf{a})$$
\item \texttt{BGV.Enc($\texttt{pk},\textbf{m}$)}: $$\texttt{ct}=([ \mathbf{m}+\mathbf{u}\cdot\texttt{pk}_0+p\mathbf{e}_0]_q,[\mathbf{u}\cdot\texttt{pk}_1+p\mathbf{e}_1]_q)$$
\end{itemize}
We need to evaluate the effect of the encryption function $\texttt{Enc}$ and the decryption function $\texttt{Dec}$ on noise. Consider the following equation:
\begin{equation}
\texttt{ct}_0+\texttt{ct}_1\cdot{s}=\Delta\mathbf{m}+p\mathbf{v}
\end{equation}

The noise $\mathbf{v}$ can be evaluated by $\lVert\mathbf{v}\rVert_\infty < (q-p r_t(q))/(2p)$ where $r_p(q)=q-p\Delta$ which is a value determined by the modulus $q$, the plaintext scaling factor $\Delta$ and the noise ratio $p$.

This condition exists because during the decryption process we actually perform a $p/q$ scaling operation. This scaling operation may amplify the effect of the noise, so we need to make sure that the size of the noise is within an acceptable range before decryption.

% \begin{equation}
% 	\begin{aligned}
% 		\texttt{BFV.EvalAdd($\texttt{ct}_1,\texttt{ct}_2$)}&=(\texttt{ct}_1+\texttt{ct}_2)_0,(\texttt{ct}_1+\texttt{ct}_2)_1\\
% 		\texttt{BFV.EvalMul($\texttt{ct}_1,\texttt{ct}_2$)}&=(\texttt{ct}_1\cdot\texttt{ct}_2)_0,(\texttt{ct}_1\cdot\texttt{ct}_2)_1
% 	\end{aligned}
% \end{equation}
% This chapter primarily addresses the wireless signal strength model, focusing particularly on the signal transmission model applicable to space satellites and terrestrial receivers. Central to the discussion are two key assumptions pivotal to consensus algorithms: spatial continuity and temporal continuity. Instead of delving deep into the intricacies of the related formulas, this chapter accords higher importance to the qualitative conclusions derived from these equations.

\subsection{Network Architecture}
\paragraph{Hostnet and subnet.}
Consider a network composed of a set of participants $V$ in which the majority obey a protocol to reach Byzantine Agreement and finality\cite{grandpa} over ledger $L$. $S_{i}$ is a subset of $V$, \( V = S_{0} \cup S_{1} \cup .. \cup S_{n-1}  \). We call $V$ is a \textit{hostnet} and $S_{i}$ is a \textit{subnet} of $V$.
\begin{itemize}
\item A node participant \( v \in V \) could be a member of any $S_{i}$ at meantime.\( v \in V, v \in S_{m} \cap S_{n} \) is valid.
\item We assume the ledger $L$ of hostnet maintains all the subnets information in form of a mapping \textit{subnet id}\( \rightarrow \)\textit{node list}.
\item Any participant of the hostnet could join a specific subnet through proposing a modification over ledger $L$.
\item Since the ledger $L$ is under Byzantine Agreement by all participants, the map can be considered a provable information outside any subnets.
\end{itemize}

\paragraph{Subnet ledger.}
For each subnet $S_{i}$, all participants \(v_{j} \in S_{i}\) maintain an independent ledger $L_{i}$ different from the ledger $L$ of hostnet, while the root state of each subnet ledger will be recorded in the hostnet ledger, \( L_{i} \nsubseteq L, F(L_{i}) \in L \).

We want to formalise the procedure of reaching consensus on the ledger across all participants as a protocol that can be deployed along with any kind of blockchain network to build subnet. We can assume that the subnet ledger has properties as below:

\begin{itemize}
\item The subnet ledger contains all the modification events and each event has an increasemental number as index.
The ledger is expected to be in a deterministic state after the $n_{th}$ event being applied, \(S_{n+1} = f(S_{n}, e_{n})\).
\item Particularly, changing the function $f$ is also a kind of event. The first event $e_{0}$ is loading the function.
\item The time complexity of looking up the $n_{th}$ event is $O(1)$.
\item The time complexity of retrieving the maximum event id is $O(1)$.
\end{itemize}

\paragraph{Subnet topology and token.}
The participants of the subnet strictly follows the sequence of the \textit{node list} to form a ring topology.
A \textit{token} $T$ of a subnet with $n$ nodes is a special signal circulates around the ring following the sequence of the \textit{node list}.

\begin{itemize}
\item The token carries groups of events from its sender and the sender{'}s forehead recursively.
Group $G_{i}$ is composed by the node $v_{i}$. It contains a list of modification events originally from its pending request queue, the node{'}s digital signature, a digest of its local ledger after these modification applied, a number $q$ indicates how many times this group should delivered and the nonce of the signer:
\begin{equation}
G_{i} = (E = [e_{k}, e_{k+1}..e_{k+n}], S_{k+n}, sig(nonce, E, S_{k+n}), nonce, q)
\end{equation}
The event list $E$ could be empty, the $q$ could be negative.

\item Normally, a token circulates in a subnet with $n$ nodes should always include $n$ groups unless there were malicious behaviors or some nodes went offline.
Whenever a node receives the token, it ought to check the signature for each group.
Then applying all the events of each group and compare the digest with the local ledger.
The $q$ of executed groups should be decreased by 1.

\item If all checks pass, the node should handle transactions from its local queue and compose them as a new group with initial $q=n-1$ to replace previous one in the token.
Then try to deliver the token to its successor.
\end{itemize}

Assume a subnet with $n$ nodes \( v_{0}, v_{1} .. v_{n-1}, n\geq 3\). If no nodes joined the subnet during last round, when a node $v_{i}$ receives the token $T$, noted as $T_{i}$.
\begin{eqnarray}
T_{i} &=& G_{i}, G_{(i + 1)\mod n},.., G_{(i + n - 1)\mod n}\\
T_{i+1} &=& G_{i+1}, G_{(i+2)\mod n},..,G_{i}^{\prime}; i+1<n
\end{eqnarray}

\paragraph{Function upgrade.}


\paragraph{Join and leave a subnet.} TODO
As a sub protocol running along with a blockchain system, Monadring DOES NOT decide the members of subnets but follow the consensus of hostnet.
In another word, the subnet nodes just handle the node joining and leaving events confirmed by hostnet.

To join or leave a subnet, the node as a member of hostnet should submit a proposal to modify the hostnet ledger identified the node id.
Typically the hostnet finality only requires a part of confirmations from all validators\cite{granpd},

\paragraph{Fault tolerence.}
The hostnet can reach the Byzantine Agreement over $L$ based on an assumption that the ratio of honest participants $r > threshold$.
We don{'}t expect that a subnet has a same ratio. We neither don{'}t expect that a node is honest on ledger $L$ would be honest on subnet legder $L_{i}$.
We want to find a solution to detect the malicious behaviours or nodes offline then exclude them from the subnet by a provable invalidity.

For simplicity, we note $T_{i/i}$ as $T_{i}$ excluding the $i_{th}$ group. An valid $T_{i}$ must satisfy properties as below:

\begin{itemize}
\item The $q$ of $G_{i}$ satisfies \(q \leq 0\). $q=0$ implies no new nodes joined the subnet in this round, while $q < 0$ implies some new nodes have joined the subnet. The node $v_{i}$ can check the \textit{node list} from $L$.
For rest $q$ of $\forall G \in T_{i/i}$ are similar.
\item TODO check signatures.
\item Assume the maximum event id of $G_{i}$ is $m$. Combine all event lists of $T_{i/i}$ as a single list $E_{i/i}$. Assume the minimal event id of $E_{i/i}$ is $n$.
\(n = m+1\) and $m$ is the maximum event id of node $v_{i}$.
\end{itemize}


\paragraph{Blind challenge.} % Id like to describe that Monadring supports small set of participants. e.g. only 1 participant

\section{The Monadring Protocol}

\bibliography{monadring}
\end{document}

\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}

\bibliographystyle{plain}

\begin{document}

\title{Monadring: A lightweight consensus algorithm for organizing subnets upon a blockchain system}
\author{Zhang Yu, Gang Tang}
\date{June 15, 2024}
\maketitle

\begin{abstract}
Existing blockchain networks are often large-scale, requiring transactions to be synchronized across the entire network to reach consensus, and on-chain computations can be prohibitively expensive, making many CPU-sensitive computations infeasible. Inspired by the structure of IBM's token ring networks, we propose a lightweight consensus algorithm called Monadring to address these issues. Monadring allows nodes that are already part of a large blockchain network to form a smaller subnetwork to perform computations more quickly and cheaply, while still maintaining the same security guarantees as the main blockchain network. The paper details the design and implementation of the Monadring algorithm, and evaluates its performance and feasibility through simulation experiments. This research contributes to enhancing the practical utility of blockchain technology in large-scale application scenarios.
\end{abstract}

\section{Introduction}

Recent blockchain systems have often adopted faster and more energy-efficient consensus protocols like Ouroboros, BABE, and Tendermint.
Blockchain networks are typically open and permissionless, and we can define the degree of decentralization of such networks by the number of participating nodes.
Leveraging the consensus algorithms mentioned earlier, it is possible to rapidly construct new blockchain networks.
However, decentralized applications often cannot flexibly customize their degree of decentralization based on the importance of their underlying data.

For example, decentralized social media applications may require faster response times and lower storage costs compared to decentralized finance applications, and hence may need a lower degree of decentralization.
This flexibility to adjust the level of decentralization based on the needs of the application is an important consideration that has not been fully addressed in existing blockchain architectures.

Building a subnetwork over an existing blockchain system is a possible way to address this issue.
By drawing inspiration from the token ring architecture, we propose a novel consensus algorithm called Monadring that aims to enable nodes within an existing blockchain network to form smaller, lightweight subnetworks capable of performing computations more efficiently and cost-effectively, while still maintaining the same security guarantees as the main blockchain.

Token ring network operates at the data link layer of the OSI/RM model.
It was designed to solve the problem of physical link contention just like Ethernet.
In a token ring network, a token is passed sequentially from one node to the next, granting the holder the right to transmit data.
This token-based system for managing access to the shared medium bears some similarity to the consensus mechanisms used in blockchain networks for selecting block producer.

Despite the fact that token ring networks have largely fallen out of favor in modern networking due to their limited scalability and other drawbacks, the underlying principles of their decentralized, token-based structure could provide valuable insights for designing a lightweight consensus algorithm for small blockchain systems.

\section{Definitions and Model}
\paragraph{Hostnet and subnet.}
Consider a network composed of a set of participants $V$ in which the majority obey a protocol to reach Byzantine Agreement and finality\cite{grandpa} over ledger $L$. $S_{i}$ is a subset of $V$, \( V = S_{0} \cup S_{1} \cup .. \cup S_{n-1}  \). We call $V$ is a \textit{hostnet} and $S_{i}$ is a \textit{subnet} of $V$.
\begin{itemize}
\item A node participant \( v \in V \) could be a member of any $S_{i}$ at meantime.\( v \in V, v \in S_{m} \cap S_{n} \) is valid.
\item We assume the ledger $L$ of hostnet maintains all the subnets information in form of a mapping \textit{subnet id}\( \rightarrow \)\textit{node list}.
\item Any participant of the hostnet could join a specific subnet through proposing a modification over ledger $L$.
\item Since the ledger $L$ is under Byzantine Agreement by all participants, the map can be considered a provable information outside any subnets.
\end{itemize}

\paragraph{Subnet ledger.}
For each subnet $S_{i}$, all participants \(v_{j} \in S_{i}\) maintain an independent ledger $L_{i}$ different from the ledger $L$ of hostnet, while the root state of each subnet ledger will be recorded in the hostnet ledger, \( L_{i} \nsubseteq L, \digamma(L_{i}) \in L \).

We want to formalise the procedure of reaching consensus on the ledger across all participants as a protocol that can be deployed along with any kind of blockchain network to build subnet. We can assume that the subnet ledger has properties as below:

\begin{itemize}
\item The subnet ledger contains all the modification events and each event has an increasemental number as index.
The ledger is expected to be in a deterministic state after the $n_{th}$ event being applied, \(S_{n+1} = f(S_{n}, e_{n})\).
\item Particularly, changing the function $f$ is also a kind of event. The first event $e_{0}$ is loading the function.
\item The time complexity of looking up the $n_{th}$ event is $O(1)$.
\item The time complexity of retrieving the maximum event id is $O(1)$.
\end{itemize}


\paragraph{Subnet topology and token.}

The participants of the subnet strictly follows the sequence of the \textit{node list} to form a ring topology.
A \textit{token} $T$ of a subnet with $n$ nodes is a special signal circulates around the ring following the sequence of the \textit{node list}.

\begin{itemize}
\item The token carries groups of events from its sender and the sender{'}s forehead recursively.
Group $G_{i}$ is composed by the node $v_{i}$. It contains a list of modification events originally from its pending request queue, the node{'}s digital signature, a digest of its local ledger after these modification applied, a number $q$ indicates how many times this group should delivered and the nonce of the signer:
        \[G_{i} = (E = [e_{k}, e_{k+1}..e_{k+n}], S_{k+n}, signature(nonce, E, S_{k+n}), nonce, q)\]
The event list $E$ could be empty.

\item Normally, a token circulates in a subnet with $n$ nodes should always include $n$ groups unless there were malicious behaviors or some nodes went offline.
Whenever a node receives the token, it ought to check the signature and $q$ for each group.
Then applying all the events of each group and compare the digest with the local ledger.
The $q$ of executed groups should be decreased by 1.

\item If all checks pass, the node should handle transactions from its local queue and compose them as a new group with initial $q=n-1$ to replace previous one in the token.
Then try to deliver the token to its successor.
\end{itemize}

\paragraph{Malicious behaviours and offline.} TODO

\paragraph{Blind challenge.} TODO % Id like to describe that Monadring supports small set of participants. e.g. only 1 participant

\section{The Monadring Protocol}

\bibliography{monadring}
\end{document}
